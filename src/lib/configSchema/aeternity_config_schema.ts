// Json schema downloaded from https://raw.githubusercontent.com/aeternity/aeternity/9ba79d6d08fb5fa2fc5679455a8cd41004ae4605/apps/aeutils/priv/aeternity_config_schema.json

// Generated by ts-to-zod
import { z } from "zod";

/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
export const aeternityConfigSchemaSchema = z.object({
  system: z
    .object({
      /**
       * When true, the node disables sync, mining, http endpoints etc
       */
      maintenance_mode: z.boolean().optional(),
      /**
       * When true, the node disables sync, mining, but keeps http endpoints open
       */
      offline_mode: z.boolean().optional(),
      /**
       * When true, the node sets up for development (default netw id: ae_dev, default consensus: on_demand)
       */
      dev_mode: z.boolean().optional(),
      /**
       * Directory containing Aeternity node plugins
       */
      plugin_path: z.string().optional(),
      /**
       * List of application names of plugins to load
       */
      plugins: z
        .array(
          z.record(z.unknown()).and(
            z.object({
              /**
               * Erlang application name of plugin
               */
              name: z.string(),
              /**
               * Configuration for the given plugin
               */
              config: z.record(z.unknown()).optional(),
            })
          )
        )
        .optional(),
      /**
       * Overrides the automatically derived file name for prefunded accounts. No default value
       */
      custom_prefunded_accs_file: z.string().optional(),
    })
    .optional(),
  /**
   * Pre-configured addresses of nodes to contact. If not set testnet or mainnet seed peers will be used based on network_id configuration value.
   */
  peers: z.array(z.string()).optional(),
  /**
   * If the default peers shall be added as trusted peers. Note: setting this to false means that the default seed nodes would not be used and a proper set of peers had been added instead.
   */
  include_default_peers: z.boolean().optional(),
  /**
   * Pre-configured addresses of nodes NOT to contact
   */
  blocked_peers: z.array(z.string()).optional(),
  mempool: z
    .object({
      /**
       * Number of blocks before inactive TXs are garbage collected. Default: `(60 div 3) * 24 * 2 * 7`
       */
      tx_ttl: z.number().optional(),
      /**
       * Number of blocks before invalid (TTL or low nonce) TXs are garbage collected
       */
      invalid_tx_ttl: z.number().optional(),
      /**
       * Interval between mempool (re-)synchronization (in ms) Default: `30 * 60 * 1000`
       */
      sync_interval: z.number().optional(),
      /**
       * Maximum nonce offset accepted
       */
      nonce_offset: z.number().optional(),
      /**
       * Maximum nonce accepted when pubkey is not present in state
       */
      nonce_baseline: z.number().optional(),
      /**
       * Maximum number of recently received cached transactions
       */
      cache_size: z.number().optional(),
      /**
       * Allow already deleted transactions to reenter the tx-pool.
       */
      allow_reentry_of_txs: z.boolean().optional(),
      tx_failures: z
        .object({
          /**
           * If true, the following error codes will have specific failures.
           */
          enabled: z.boolean().optional(),
          common: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * Something went really wrong, clean up.
                 */
                crash: z.number().optional(),
                /**
                 * If the transaction is being authenticated as a GA but the account is still basic. We provide a grace period in a number of generations for the account to be upgraded.
                 */
                not_a_generalized_account: z.number().optional(),
                /**
                 * If the transaction nonce is already used, the transaction can not be applied. Clean it up.
                 */
                tx_nonce_already_used_for_account: z.number().optional(),
                /**
                 * If the transaction nonce is set somewhere in the future it can get included once the transaction with the missing nonce is being included. Provide a grace period in a number of generations.
                 */
                tx_nonce_too_high_for_account: z.number().optional(),
              })
            )
            .optional(),
          spend_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
              })
            )
            .optional(),
          name_preclaim_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
              })
            )
            .optional(),
          name_claim_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If there is something unexpected about the transaciton. Clean up.
                 */
                bad_transaction: z.number().optional(),
                /**
                 * If the origin of the transaction does not have ownership to the commitment. Legacy. Clean up.
                 */
                name_not_preclaimed: z.number().optional(),
                /**
                 * If the origin of the transaction does not have ownership to the commitment. Clean up.
                 */
                commitment_not_owned: z.number().optional(),
                /**
                 * If the commitment had not yet matured, provide a grace period for it.
                 */
                commitment_delta_too_small: z.number().optional(),
                /**
                 * If the name is already registered. Clean up.
                 */
                name_already_taken: z.number().optional(),
                /**
                 * If the registrar is not available, if there is an upcoming fork to allow new registrars - provide a grace period for it, otherwise clean up.
                 */
                invalid_registrar: z.number().optional(),
                /**
                 * If the fee is insufficient for the name. If there is an upcoming fork that changes pricing - provide a grace period for it, otherwise clean up.
                 */
                invalid_name_fee: z.number().optional(),
              })
            )
            .optional(),
          name_revoke_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If the name is not owned by the origin of the transaction. Clean up.
                 */
                name_not_owned: z.number().optional(),
                /**
                 * If the the name is already revoked. Clean up
                 */
                name_revoked: z.number().optional(),
              })
            )
            .optional(),
          name_transfer_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If the name is not owned by the origin of the transaction. Clean up.
                 */
                name_not_owned: z.number().optional(),
                /**
                 * If the the name is already revoked. Clean up
                 */
                name_revoked: z.number().optional(),
              })
            )
            .optional(),
          name_update_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If the provided TTL is too far away in the future. If there is an upcoming fork that changes pricing - provide a grace period for it, otherwise clean up.
                 */
                ttl_too_high: z.number().optional(),
                /**
                 * If the provided TTL is too soon. If there is an upcoming fork that changes pricing - provide a grace period for it, otherwise clean up.
                 */
                ttl_too_low: z.number().optional(),
                /**
                 * If the provided TTL is using unknown format. If there is an upcoming fork that changes pricing - provide a grace period for it, otherwise clean up.
                 */
                ttl_invalid: z.number().optional(),
                /**
                 * If the name is not owned by the origin of the transaction. Clean up.
                 */
                name_not_owned: z.number().optional(),
                /**
                 * If the name is already revoked. Clean up
                 */
                name_revoked: z.number().optional(),
                /**
                 * If the provided pointers fail the required checks. If there is an upcoming fork that changes pricing - provide a grace period for it, otherwise clean up.
                 */
                invalid_pointers: z.number().optional(),
              })
            )
            .optional(),
          channel_create_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
              })
            )
            .optional(),
          channel_close_mutual_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If the channel to be closed is not present. We provide a grace period in a number of generations.
                 */
                channel_does_not_exist: z.number().optional(),
                /**
                 * If the origin of the transaction is not a channel peer. Clean up.
                 */
                account_not_peer: z.number().optional(),
                /**
                 * If the channel is already closing. Clean up.
                 */
                channel_not_active: z.number().optional(),
                /**
                 * If the channel closing amounts exceed the channel balance. There could be a hanging channel_deposit_tx, provide a grace period.
                 */
                wrong_amounts: z.number().optional(),
              })
            )
            .optional(),
          channel_deposit_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If the channel to be deposited is not present. We provide a grace period in a number of generations.
                 */
                channel_does_not_exist: z.number().optional(),
                /**
                 * If the channel is already closing. Clean up.
                 */
                channel_not_active: z.number().optional(),
                /**
                 * If the channel deposit is based on a round older than the on-chain stored one. Clean up.
                 */
                old_round: z.number().optional(),
                /**
                 * If the channel deposit is trying to replace current state hash. Clean up.
                 */
                same_round: z.number().optional(),
              })
            )
            .optional(),
          channel_withdraw_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If the channel to be withdrawn from is not present. We provide a grace period in a number of generations.
                 */
                channel_does_not_exist: z.number().optional(),
                /**
                 * If the channel is already closing. Clean up.
                 */
                channel_not_active: z.number().optional(),
                /**
                 * If the channel withdrawal is based on a round older than the on-chain stored one. Clean up.
                 */
                old_round: z.number().optional(),
                /**
                 * If the channel withdrawal is trying to replace current state hash. Clean up.
                 */
                same_round: z.number().optional(),
                /**
                 * If the channel withdrawal is trying to withdraw more tokens than the current channels balance allows it to.  There could be a hanging channel_deposit_tx, provide a grace period.
                 */
                not_enough_channel_funds: z.number().optional(),
              })
            )
            .optional(),
          channel_settle_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If the channel to be settled is not present. We provide a grace period in a number of generations.
                 */
                channel_does_not_exist: z.number().optional(),
                /**
                 * If the origin of the transaction is not a channel peer. Clean up.
                 */
                account_not_peer: z.number().optional(),
                /**
                 * If the channel dispute time interval is still active. Provide a grace period.
                 */
                channel_not_closed: z.number().optional(),
                /**
                 * If the channel final amounts do not match the closing amounts. There could be a hanging channel_slash_tx, provide a grace period.
                 */
                wrong_amt: z.number().optional(),
                /**
                 * If the channel final amounts exceedthe channel balance. Clean up.
                 */
                insufficient_channel_funds: z.number().optional(),
              })
            )
            .optional(),
          channel_close_solo_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If the channel to be closed is not present. We provide a grace period in a number of generations.
                 */
                channel_does_not_exist: z.number().optional(),
                /**
                 * If the origin of the transaction is not a channel peer. Clean up.
                 */
                account_not_peer: z.number().optional(),
                /**
                 * If the channel is already closing. Clean up.
                 */
                channel_not_active: z.number().optional(),
                /**
                 * If the payload is from an unknown format, if there is an upcoming fork to allow new serializations - provide a grace period for it, otherwise clean up.
                 */
                payload_deserialization_failed: z.number().optional(),
                /**
                 * If the offhchain state is from an unknown off-chain transaction type, if there is an upcoming fork to allow new off-chain transaction types - provide a grace period for it, otherwise clean up.
                 */
                bad_offchain_state_type: z.number().optional(),
                /**
                 * If the origin of the transaction is not in the state tree. Clean up.
                 */
                account_not_found: z.number().optional(),
                /**
                 * If the root of the proof of inclusion for the off-chain state does not match the provided hash. Clean up.
                 */
                invalid_poi_hash_in_channel: z.number().optional(),
                /**
                 * If the channel id of the payload off-chain transaction does not match the transaction channel id. Clean up.
                 */
                bad_state_channel_pubkey: z.number().optional(),
                /**
                 * If the transaction is based on a round older than the on-chain stored one. Clean up.
                 */
                old_round: z.number().optional(),
                /**
                 * If the transaction is trying to replace current state hash. Clean up.
                 */
                same_round: z.number().optional(),
                /**
                 * If the payload authentication failed. Clean up.
                 */
                signature_check_failed: z.number().optional(),
                /**
                 * If the accounts provided in the PoI are not of the channel participants. Clean up.
                 */
                wrong_channel_peers: z.number().optional(),
                /**
                 * If the amounts of accounts provided in the PoI exceed the total channel balance. Clean up.
                 */
                poi_amounts_change_channel_funds: z.number().optional(),
              })
            )
            .optional(),
          channel_slash_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If the channel to be slashed is not present. We provide a grace period in a number of generations.
                 */
                channel_does_not_exist: z.number().optional(),
                /**
                 * If the origin of the transaction is not a channel peer. Clean up.
                 */
                account_not_peer: z.number().optional(),
                /**
                 * If the channel is not yet closing. There might be a close solo hanging in the pool, provide a grace period.
                 */
                channel_not_closing: z.number().optional(),
                /**
                 * If the payload is from an unknown format, if there is an upcoming fork to allow new serializations - provide a grace period for it, otherwise clean up.
                 */
                payload_deserialization_failed: z.number().optional(),
                /**
                 * If the offhchain state is from an unknown off-chain transaction type, if there is an upcoming fork to allow new off-chain transaction types - provide a grace period for it, otherwise clean up.
                 */
                bad_offchain_state_type: z.number().optional(),
                /**
                 * If the origin of the transaction is not in the state tree. Clean up.
                 */
                account_not_found: z.number().optional(),
                /**
                 * If the root of the proof of inclusion for the off-chain state does not match the provided hash. Clean up.
                 */
                invalid_poi_hash_in_channel: z.number().optional(),
                /**
                 * If the channel id of the payload off-chain transaction does not match the transaction channel id. Clean up.
                 */
                bad_state_channel_pubkey: z.number().optional(),
                /**
                 * If the transaction is based on a round older than the on-chain stored one. Clean up.
                 */
                old_round: z.number().optional(),
                /**
                 * If the transaction is trying to replace current state hash. Clean up.
                 */
                same_round: z.number().optional(),
                /**
                 * If the payload authentication failed. Clean up.
                 */
                signature_check_failed: z.number().optional(),
                /**
                 * If the accounts provided in the PoI are not of the channel participants. Clean up.
                 */
                wrong_channel_peers: z.number().optional(),
                /**
                 * If the amounts of accounts provided in the PoI exceed the total channel balance. Clean up.
                 */
                poi_amounts_change_channel_funds: z.number().optional(),
                /**
                 * If the slash transaction comes with an empty payload. Clean up.
                 */
                slash_must_have_payload: z.number().optional(),
              })
            )
            .optional(),
          channel_snapshot_solo_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If the payload is from an unknown format, if there is an upcoming fork to allow new serializations - provide a grace period for it, otherwise clean up.
                 */
                payload_deserialization_failed: z.number().optional(),
                /**
                 * If the snapshot transaction comes with an empty payload. Clean up.
                 */
                snapshot_must_have_payload: z.number().optional(),
                /**
                 * If the offhchain state is from an unknown off-chain transaction type, if there is an upcoming fork to allow new off-chain transaction types - provide a grace period for it, otherwise clean up.
                 */
                bad_offchain_state_type: z.number().optional(),
                /**
                 * If the channel to be snapshot is not present. We provide a grace period in a number of generations.
                 */
                channel_does_not_exist: z.number().optional(),
                /**
                 * If the origin of the transaction is not in the state tree. Clean up.
                 */
                account_not_found: z.number().optional(),
                /**
                 * If the origin of the transaction is not a channel peer. Clean up.
                 */
                account_not_peer: z.number().optional(),
                /**
                 * If the channel is already closing. Clean up.
                 */
                channel_not_active: z.number().optional(),
                /**
                 * If the channel deposit is based on a round older than the on-chain stored one. Clean up.
                 */
                old_round: z.number().optional(),
                /**
                 * If the channel deposit is trying to replace current state hash. Clean up.
                 */
                same_round: z.number().optional(),
                /**
                 * If the payload authentication failed. Clean up.
                 */
                signature_check_failed: z.number().optional(),
              })
            )
            .optional(),
          channel_set_delegates_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If the channel to be set is not present. We provide a grace period in a number of generations.
                 */
                channel_does_not_exist: z.number().optional(),
                /**
                 * If the offhchain state is from an unknown off-chain transaction type, if there is an upcoming fork to allow new off-chain transaction types - provide a grace period for it, otherwise clean up.
                 */
                bad_offchain_state_type: z.number().optional(),
                /**
                 * If the payload is from an unknown format, if there is an upcoming fork to allow new serializations - provide a grace period for it, otherwise clean up.
                 */
                payload_deserialization_failed: z.number().optional(),
                /**
                 * If the origin of the transaction is not in the state tree. Clean up.
                 */
                account_not_found: z.number().optional(),
                /**
                 * If the origin of the transaction is not a channel peer. Clean up.
                 */
                account_not_peer: z.number().optional(),
                /**
                 * If the channel is already closing. Clean up.
                 */
                channel_not_active: z.number().optional(),
                /**
                 * If the set delegates is based on the latest state hash which is different. We provide a grace period in a number of generations.
                 */
                unexpected_state_hash: z.number().optional(),
                /**
                 * If the set delegates is based on the latest round which is different. We provide a grace period in a number of generations.
                 */
                unexpected_round: z.number().optional(),
              })
            )
            .optional(),
          contract_create_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If the VM version is not supported. If there is an upcoming hard fork - provide a grace period, otherwise - clean up
                 */
                illegal_vm_version: z.number().optional(),
                /**
                 * If the compiler version is not supported. If there is an upcoming hard fork - provide a grace period, otherwise - clean up
                 */
                illegal_contract_compiler_version: z.number().optional(),
                /**
                 * If the sophia code does not parse. If there is an upcoming hard fork - provide a grace period, otherwise - clean up
                 */
                bad_sophia_code: z.number().optional(),
                /**
                 * If the init function fails. If there is an upcoming hard fork - provide a grace period, otherwise - clean up
                 */
                bad_init_function: z.number().optional(),
              })
            )
            .optional(),
          contract_call_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If the VM version is not supported. If there is an upcoming hard fork - provide a grace period, otherwise - clean up
                 */
                illegal_vm_version: z.number().optional(),
              })
            )
            .optional(),
          ga_attach_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If the VM version is not supported. If there is an upcoming hard fork - provide a grace period, otherwise - clean up
                 */
                illegal_vm_version: z.number().optional(),
              })
            )
            .optional(),
          oracle_register_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If account is already an oracle. Clean up
                 */
                account_is_already_an_oracle: z.number().optional(),
                /**
                 * If the ABI version is not supported. If there is an upcoming hard fork - provide a grace period, otherwise - clean up
                 */
                bad_abi_version: z.number().optional(),
                /**
                 * If the query format is not supported. If there is an upcoming hard fork - provide a grace period, otherwise - clean up
                 */
                bad_query_format: z.number().optional(),
                /**
                 * If the response format is not supported. If there is an upcoming hard fork - provide a grace period, otherwise - clean up
                 */
                bad_response_format: z.number().optional(),
              })
            )
            .optional(),
          oracle_extend_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If account is not an oracle. Clean up
                 */
                account_is_not_an_active_oracle: z.number().optional(),
              })
            )
            .optional(),
          oracle_query_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If oracle does not exist. Clean up
                 */
                oracle_does_not_exist: z.number().optional(),
                /**
                 * If the query format does not match up. Clean up
                 */
                bad_format: z.number().optional(),
                /**
                 * If the fee provided does not match expectations. Clean up
                 */
                query_fee_too_low: z.number().optional(),
                /**
                 * If the ttl provided does not match expectations. Clean up
                 */
                too_long_ttl: z.number().optional(),
              })
            )
            .optional(),
          oracle_response_tx: z
            .record(z.unknown())
            .and(
              z.object({
                /**
                 * Default value if the failed reason is not set.
                 */
                fallback: z.number().optional(),
                /**
                 * If the origin of the transaction does not have enough tokens to spend. We provide a grace period in a number of generations.
                 */
                insufficient_funds: z.number().optional(),
                /**
                 * If oracle does not exist. Clean up
                 */
                oracle_does_not_exist: z.number().optional(),
                /**
                 * If the query format does not match up. Clean up
                 */
                bad_format: z.number().optional(),
                /**
                 * If there is no matching query id. Provide a grace period
                 */
                no_matching_oracle_query: z.number().optional(),
              })
            )
            .optional(),
        })
        .optional(),
    })
    .optional(),
  sync: z
    .object({
      /**
       * If true, UPnP & NAT-PMP discovery will be enabled and port mapping will be established.
       */
      upnp_enabled: z.boolean().optional(),
      /**
       * Listen address for external interface. This should be publicly accessible
       */
      listen_address: z.string().optional(),
      /**
       * Local port used for incoming sync connections. If behind NAT this may differ from the 'external_port' value.
       */
      port: z.number().optional(),
      /**
       * Interval between pings (in ms)
       */
      ping_interval: z.number().optional(),
      /**
       * Listen port for external sync connections. This must be the WAN-facing port number (depending on NAT configuration this may be different from 'port' value above).
       */
      external_port: z.number().optional(),
      /**
       * Number of acceptors in listening pool
       */
      acceptors: z.number().optional(),
      /**
       * Connection timeout in milliseconds
       */
      connect_timeout: z.number().optional(),
      /**
       * Maximum time for receiving a ping in milliseconds
       */
      first_ping_timeout: z.number().optional(),
      /**
       * Maximum time for noise handshake in milliseconds
       */
      noise_hs_timeout: z.number().optional(),
      /**
       * Maximum time for the peer to close a connection cleanly
       */
      close_timeout: z.number().optional(),
      /**
       * Maximum number of inbound connections after which inbound connections are temporary (only used for a single ping)
       */
      max_inbound: z.number().optional(),
      /**
       * Maximum number of inbound connections
       */
      max_inbound_hard: z.number().optional(),
      /**
       * Maximum number of outbound connections
       */
      max_outbound: z.number().optional(),
      /**
       * Maximum number of peers to gossip blocks and transactions to
       */
      max_gossip: z.number().optional(),
      /**
       * If the extra outbound connections should be to nodes from different address groups (IP netmask /16)
       */
      single_outbound_per_group: z.boolean().optional(),
      /**
       * The number of peers sent in ping message
       */
      gossiped_peers_count: z.number().optional(),
      /**
       * Maximum number of retries at resolving the host name of untrusted peers.
       */
      resolver_max_retries: z.number().optional(),
      /**
       * Waiting time intervals (milliseconds) before each retry at resolving the host name of peers (both trusted and untrusted). Retries further to the length of the array reuse the last item of the array.
       *
       * @minItems 1
       */
      resolver_backoff_times: z.tuple([z.number(), z.any()]).optional(),
      /**
       * Allowed height difference from current top for incoming blocks (via gossip)
       */
      gossip_allowed_height_from_top: z.number().optional(),
      /**
       * Once own node is synced, reject sync blocks at least this far from the current top; 0 means disabled
       */
      sync_allowed_height_from_top: z.number().optional(),
      /**
       * If sync_allowed_height_from_top > 0, this is applied at startup
       */
      resist_forks_from_start: z.boolean().optional(),
      /**
       * The name of a block hash whitelist file (JSON format)
       */
      whitelist_file: z.string().optional(),
      /**
       * Time (milliseconds) between logging info about connected peers
       */
      log_peer_connection_count_interval: z.number().optional(),
      peer_pool: z
        .record(z.unknown())
        .and(
          z.object({
            /**
             * Probability of selecting a peer from the verified pool.
             */
            select_verified_peer_probability: z.number().optional(),
            /**
             * Time (milliseconds) without a peer being updated after which it gets removed.
             */
            max_update_lapse: z.number().optional(),
            /**
             * Waiting time intervals (milliseconds) before each retry to connect to a peer. If there are more 'max_rejections' than elements in this list, the last retry time is used more than once.
             *
             * @minItems 1
             */
            standby_times: z.tuple([z.number(), z.any()]).optional(),
            /**
             * The default maximum number of times a peer can get rejected. When reached, the peer is downgraded or removed (if not trusted).
             */
            max_rejections: z.number().optional(),
          })
        )
        .optional(),
      /**
       * Provide node version to peers
       */
      provide_node_info: z.boolean().optional(),
      /**
       * If enabled aggregates info about remote peers and exposes them via HTTP. Overrides max_inbound and max_outbound
       */
      peer_analytics: z.boolean().optional(),
    })
    .optional(),
  http: z
    .object({
      /**
       * Section for CORS headers configuration.
       */
      cors: z
        .object({
          /**
           * List of domains that can access resources. Use '*' to allow all domains.
           *
           * @minItems 1
           */
          allow_domains: z.tuple([z.string(), z.any()]).optional(),
          /**
           * List of allowed headers to be used with requests (to be set in access-control-request-headers header in the response). Use '*' or do not set at all to allow all headers.
           *
           * @minItems 1
           */
          allow_headers: z.tuple([z.string(), z.any()]).optional(),
          /**
           * List of allowed methods allowed to be used when accessing resources (to be set in access-control-allow-methods header in the response).
           *
           * @minItems 1
           */
          allow_methods: z.tuple([z.string(), z.any()]).optional(),
          /**
           * Indicates for how many seconds the results of a preflight request can be cached (to be set in access-control-max-age header in the response).
           */
          max_age: z.number().optional(),
        })
        .optional(),
      protocol_options: z
        .object({
          /**
           * Cowboy limit to request body size
           */
          max_skip_body_length: z.number().optional(),
        })
        .optional(),
      external: z
        .object({
          /**
           * Listen address for external interface. This should be publicly accessible
           */
          listen_address: z.string().optional(),
          /**
           * Listen port for external HTTP interface.
           */
          port: z.number().optional(),
          /**
           * HTTP Request timeout.
           */
          request_timeout: z.number().optional(),
          /**
           * HTTP Request connect timeout.
           */
          connect_timeout: z.number().optional(),
          /**
           * Number of acceptors in external pool
           */
          acceptors: z.number().optional(),
          /**
           * Maximum gas allowed to be available to a single dry-run call.
           */
          gas_limit: z.number().optional(),
        })
        .optional(),
      internal: z
        .object({
          /**
           * Listen address for internal interface. This should not be publicly accessible
           */
          listen_address: z.string().optional(),
          /**
           * Listen port for internal HTTP interface.
           */
          port: z.number().optional(),
          /**
           * Number of acceptors in internal pool
           */
          acceptors: z.number().optional(),
          /**
           * Enable (true) debug api. Disabled (false) by default. Debug endpoints are defined by a tag in the Swagger API schema
           */
          debug_endpoints: z.boolean().optional(),
        })
        .optional(),
      rosetta: z
        .object({
          /**
           * Listen address for rosetta interface. This can be publicly accessible, but defaults to private
           */
          listen_address: z.string().optional(),
          /**
           * Listen port for rosetta online HTTP interface.
           */
          port: z.number().optional(),
          /**
           * Number of acceptors in rosetta pool
           */
          acceptors: z.number().optional(),
        })
        .optional(),
      rosetta_offline: z
        .object({
          /**
           * Listen address for the offline rosetta interface. This can be publicly accessible, but defaults to private
           */
          listen_address: z.string().optional(),
          /**
           * Listen port for the rosetta offline HTTP interface.
           */
          port: z.number().optional(),
          /**
           * Number of acceptors in rosetta offline HTTP pool
           */
          acceptors: z.number().optional(),
        })
        .optional(),
      endpoints: z
        .object({
          /**
           * Gossip protocol API
           */
          gossip: z.boolean().optional(),
          /**
           * Name resolution API
           */
          name_service: z.boolean().optional(),
          /**
           * Chain state inspection endpoints
           */
          chain: z.boolean().optional(),
          /**
           * Transactions insection endpoints
           */
          transactions: z.boolean().optional(),
          /**
           * Node operator endpoints
           */
          "node-operator": z.boolean().optional(),
          /**
           * Development only API - for validation of client implementations. Should not be used in real life scenarios
           */
          dev: z.boolean().optional(),
          /**
           * Deprecated. See also 'http > internal > debug_endpoints'
           */
          debug: z.boolean().optional(),
          /**
           * Old endpoints that will be removed
           */
          obsolete: z.boolean().optional(),
          /**
           * External protected dry run endpoint
           */
          "dry-run": z.boolean().optional(),
        })
        .optional(),
      /**
       * Deprecated. See also 'http > internal > debug_endpoints' KILLME FIXME
       */
      debug: z.boolean().optional(),
      cache: z
        .object({
          /**
           * Enable HTTP cache headers (ETag and Expire)
           */
          enabled: z.boolean().optional(),
          /**
           * Time (in seconds) after a block is considered aged. That is an Expire header is generated for such blocks API endpoints.
           */
          aged_blocks_time: z.number().optional(),
          /**
           * Time (in seconds) to cache aged blocks, the Expire header time relative to block creation time.
           */
          aged_blocks_cache_time: z.number().optional(),
        })
        .optional(),
    })
    .optional(),
  channels: z
    .object({
      /**
       * Max number of active state channel clients allowed on node
       */
      max_count: z.number().optional(),
      /**
       * Whether to allow responders to listen on any ports other than preconfigured ones
       */
      ad_hoc_listen_ports: z.boolean().optional(),
      /**
       * Pre-configured responder listen ports
       */
      listeners: z
        .array(
          z.object({
            /**
             * Listen port number
             */
            port: z.number(),
            /**
             * Number of concurrent acceptors on port (default: 1)
             */
            acceptors: z.number().optional(),
          })
        )
        .optional(),
    })
    .optional(),
  websocket: z
    .object({
      channel: z
        .object({
          /**
           * Listen address for channels websocket interface.
           */
          listen_address: z.string().optional(),
          /**
           * Listen port for channels websocket interface.
           */
          port: z.number().optional(),
          /**
           * Number of acceptors in pool
           */
          acceptors: z.number().optional(),
        })
        .optional(),
    })
    .optional(),
  keys: z
    .object({
      /**
       * Location (directory) of the public/private key pair(s)
       */
      dir: z.string().optional(),
      /**
       * Password used to encrypt the peer key-pair files
       */
      peer_password: z.string().optional(),
    })
    .optional(),
  chain: z
    .object({
      /**
       * If true, all changes to the chain are written to disk.
       */
      persist: z.boolean().optional(),
      /**
       * Choice of database backend.
       */
      db_backend: z.string().optional(),
      /**
       * The directory where the chain is persisted to disk.
       */
      db_path: z.string().optional(),
      /**
       * Use Db backend API rather than the Mnesia API
       */
      db_direct_access: z.boolean().optional(),
      /**
       * Use Rocksdb tricks to bypass Mnesia's default update logic at tx commit
       */
      db_commit_bypass: z.boolean().optional(),
      /**
       * OBSOLETE/ignored: Maximum number of retries for failing database write operations.
       */
      db_write_max_retries: z.number().optional(),
      /**
       * The consensus protocol versions with respective effective heights. Ignored if 'fork_management > network_id' has value 'ae_mainnet' or 'ae_uat'.
       */
      hard_forks: z.record(z.number()).optional(),
      /**
       * The consensus algorithms used for validating blocks. Ignored if 'fork_management > network_id' has value 'ae_mainnet' or 'ae_uat'.
       */
      consensus: z
        .record(
          z.record(z.unknown()).and(
            z.object({
              /**
               * The type of the consensus algorithm used at the given height (ex. pow_cuckoo, smart_contract or hyper_chain)
               */
              type: z.string(),
              /**
               * Configuration for the given consensus algorithm
               */
              config: z
                .record(z.unknown())
                .and(
                  z.object({
                    /**
                     * Owner of the smart contracts that controls the consensus.
                     */
                    contract_owner: z.string().optional(),
                    /**
                     * The address of the smart contract that will be used for leader elections. For a new chain this contract should be loaded at genesis
                     */
                    election_contract: z.string().optional(),
                    /**
                     * The address of the smart contract that will be used for reward distributions. For a new chain this contract should be loaded at genesis
                     */
                    rewards_contract: z.string().optional(),
                    /**
                     * Something about rates.. FIXME
                     */
                    expected_key_block_rate: z.number().optional(),

                    lazy_leader_trigger_time: z.number(),

                    /**
                     * Details of how this node will connect to a parent chain if this is a hyperchain.
                     */
                    parent_chain: z
                      .object({
                        /**
                         * Minimum number of block confirmations required when selecting a UTXO for sending parent chain commitment transactions
                         */
                        confirmations: z.number().optional(),
                        /**
                         * Height on the parent chain that this hyperchain will start posting commitments and start creating blocks
                         */
                        start_height: z.number().optional(),

                        producing_commitments: z.boolean(),
                        /**
                         * Details of the parent chain. TODO: add 'fee' and 'amount'
                         */
                        consensus: z
                          .record(z.unknown())
                          .and(
                            z.object({
                              /**
                               * The network Id of the parent chain if it has one
                               */
                              network_id: z.string().optional(),
                              /**
                               * The address on the parent chain where commitment transactions will be sent. e.g. for a bitcoin parent chain this might start 'bcrt1'...
                               */
                              spend_address: z.string().optional(),
                              /**
                               * The type of parent network connection. Currently only AE, Bitcoin and Dogecoin are implemented
                               */
                              type: z
                                .union([
                                  z.literal("AE2AE"),
                                  z.literal("AE2BTC"),
                                  z.literal("AE2DOGE"),
                                ])
                                .optional(),
                            })
                          )
                          .optional(),
                        /**
                         * Parent chain connection
                         */
                        polling: z
                          .object({
                            /**
                             * The interval between polls of the parent chain looking for a new block (millisec)
                             */
                            fetch_interval: z.number().optional(),
                            /**
                             * List of parent chain nodes to poll for new blocks
                             */
                            nodes: z
                              .array(
                                z.object({
                                  /**
                                   * Host name of IP address
                                   */
                                  host: z.string().optional(),
                                  /**
                                   * Port number of HTTP API server on parent node
                                   */
                                  port: z.number().optional(),
                                  /**
                                   * Username for HTTP API login if needed
                                   */
                                  user: z.string().optional(),
                                  /**
                                   * Password for HTTP API login if needed
                                   */
                                  password: z.string().optional(),
                                })
                              )
                              .optional(),
                          })
                          .optional(),
                      })
                      .optional(),
                    /**
                     * List of hyperchain accounts and associated parent chain accounts that this node should post commitments for
                     */
                    stakers: z
                      .array(
                        z.object({
                          /**
                           * Child chain staking account
                           */
                          hyper_chain_account: z
                            .object({
                              /**
                               * Public key
                               */
                              pub: z.string().optional(),
                              /**
                               * Private key
                               */
                              priv: z.string().optional(),
                            })
                            .optional(),
                          /**
                           * Parent chain commitment account
                           */
                          parent_chain_account: z
                            .object({
                              /**
                               * Public key
                               */
                              pub: z.string().optional(),
                              /**
                               * Private key
                               */
                              priv: z.string().optional(),
                            })
                            .optional(),
                        })
                      )
                      .optional(),
                  })
                )
                .optional(),
            })
          )
        )
        .optional(),
      /**
       * If true, the node will split rewards and send part to protocol_beneficiaries
       */
      protocol_beneficiaries_enabled: z.boolean().optional(),
      /**
       * @minItems 1
       */
      protocol_beneficiaries: z
        .tuple([z.record(z.unknown()), z.any()])
        .optional(),
      garbage_collection: z
        .object({
          /**
           * If true, node will perform garbage collection of state trees, removing unreachable merkle patricia nodes and free some disk space
           */
          enabled: z.boolean().optional(),
          /**
           * If true, node will start garbage-collecting immediately, without waiting for sync to complete
           */
          during_sync: z.boolean().optional(),
          /**
           * Minimum height at which to trigger garbage collection
           */
          minimum_height: z.number().optional(),
          /**
           * DEPRECATED. How often (every `interval` block) should garbage collection run
           */
          interval: z.number().optional(),
          /**
           * How many generations (at least) should pass between garbage collections
           */
          history: z.number().optional(),
          /**
           * Which state trees to scan. Default: all of them
           *
           * @minItems 1
           */
          trees: z
            .tuple([
              z.union([
                z.literal("accounts"),
                z.literal("calls"),
                z.literal("channels"),
                z.literal("contracts"),
                z.literal("ns"),
                z.literal("oracles"),
              ]),
              z.any(),
            ])
            .optional(),
        })
        .optional(),
    })
    .optional(),
  mining: z
    .object({
      /**
       * If true, the node will start mining automatically.
       */
      autostart: z.boolean().optional(),
      /**
       * Maximum time (milliseconds) for each attempt to mine a block with a specific nonce.
       */
      attempt_timeout: z.number().optional(),
      /**
       * Public key of beneficiary account that will receive fees from mining on a node. Required when 'mining.autostart' is set to 'true'.
       */
      beneficiary: z.string().optional(),
      /**
       * Expected mine rate (milliseconds) between blocks. Used in governance.
       */
      expected_mine_rate: z.number().optional(),
      /**
       * Expected rate (milliseconds) between micro-blocks. Used in governance.
       */
      micro_block_cycle: z.number().optional(),
      /**
       * Minimum gas price accepted by the miner
       */
      min_miner_gas_price: z.number().optional(),
      /**
       * Maximum gas allowed for GAMetaTx authentication function
       */
      max_auth_fun_gas: z.number().optional(),
      /**
       * Delay (in key blocks / generations) for getting mining rewards. Used in governance.
       */
      beneficiary_reward_delay: z.number().optional(),
      /**
       * Blocks to wait until auction closes. Used in governance.
       */
      name_claim_bid_timeout: z.number().optional(),
      /**
       * If true, removes the risk of a race condition with eventual forking in fast mining context
       */
      strictly_follow_top: z.boolean().optional(),
      cuckoo: z
        .object({
          /**
           * Number of bits used for representing an edge in the Cuckoo Cycle problem. It affects both PoW generation (mining) and verification. WARNING: Changing this makes the node incompatible with the chain of other nodes in the network, do not change from the default unless you know what you are doing.
           */
          edge_bits: z.number().optional(),
          /**
           * Definitions of miners' configurations. If no miners are configured one miner is used as default, i.e. 'mean29-generic' executable without any extra args.
           */
          miners: z
            .array(
              z.object({
                /**
                 * Executable binary of the miner. Options are: "mean29-generic" (memory-intensive), "mean29-avx2" (memory-intensive, benefits from faster CPU supporting AVX2 instructions), "lean29-generic" (CPU-intensive, useful if memory-constrained), "lean29-avx2" (CPU-intensive, useful if memory-constrained, benefits from faster CPU supporting AVX2 instructions).
                 */
                executable: z.string(),
                /**
                 * Group of executable binaries of the miner.
                 */
                executable_group: z
                  .union([z.literal("aecuckoo"), z.literal("aecuckooprebuilt")])
                  .optional(),
                /**
                 * Extra arguments to pass to the miner executable binary. The safest choice is specifying no arguments i.e. empty string.
                 */
                extra_args: z.string().optional(),
                /**
                 * Hexadecimal encode the header argument that is send to the miner executable. CUDA executables expect hex encoded header.
                 */
                hex_encoded_header: z.boolean().optional(),
                /**
                 * DEPRECATED: Miner process priority (niceness) in a UNIX fashion. Higher `nice` means lower priority. Keep it unset to inherit parent process priority.
                 */
                nice: z.number().optional(),
                /**
                 * Number of tries to do in each miner context - WARNING: it should be set so the miner process runs for 3-5s or else the node risk missing out on new micro blocks.
                 */
                repeats: z.number().optional(),
                /**
                 * Instances used by the miner in case of Multi-GPU mining. Numbers on the configuration list represent GPU devices that are to addressed by the miner.
                 *
                 * @minItems 1
                 */
                addressed_instances: z.tuple([z.number(), z.any()]).optional(),
              })
            )
            .optional(),
          /**
           * Deprecated way of configuring single miner. Please use 'mining > cuckoo > miners' and 'mining > cuckoo > edge_bits' instead. Note that this section CAN NOT be configured when either 'mining > cuckoo > miners' or 'mining > cuckoo > edge_bits' is set.
           */
          miner: z
            .object({
              /**
               * Group of executable binaries of the miner.
               */
              executable_group: z
                .union([z.literal("aecuckoo"), z.literal("aecuckooprebuilt")])
                .optional(),
              /**
               * Executable binary of the miner. If the executable group is 'aecuckoo', the options are: "mean29-generic" (memory-intensive), "mean29-avx2" (memory-intensive, benefits from faster CPU supporting AVX2 instructions), "lean29-generic" (CPU-intensive, useful if memory-constrained), "lean29-avx2" (CPU-intensive, useful if memory-constrained, benefits from faster CPU supporting AVX2 instructions). For the other executable groups, please refer to the user documentation.
               */
              executable: z.string(),
              /**
               * Extra arguments to pass to the miner executable binary. The safest choice is specifying no arguments i.e. empty string.
               */
              extra_args: z.string(),
              /**
               * Number of bits used for representing an edge in the Cuckoo Cycle problem. It affects both PoW generation (mining) and verification. WARNING: Changing this makes the node incompatible with the chain of other nodes in the network, do not change from the default unless you know what you are doing.
               */
              edge_bits: z.number(),
              /**
               * Hexadecimal encode the header argument that is send to the miner executable. CUDA executables expect hex encoded header.
               */
              hex_encoded_header: z.boolean().optional(),
              /**
               * DEPRECATED: Miner process priority (niceness) in a UNIX fashion. Higher `nice` means lower priority. Keep it unset to inherit parent process priority.
               */
              nice: z.number().optional(),
              /**
               * Number of tries to do in each miner context - WARNING: it should be set so the miner process runs for 3-5s or else the node risk missing out on new micro blocks.
               */
              repeats: z.number().optional(),
              /**
               * Number of miner instances in case of Multi-GPU mining.
               */
              instances: z.number().optional(),
            })
            .optional(),
        })
        .optional(),
    })
    .optional(),
  logging: z
    .object({
      /**
       * Controls the overload protection in the logs. Default=50.
       */
      hwm: z.number().optional(),
      /**
       * Sets the level of logging in the default, mining, cuckoo and sync logs.
       */
      level: z
        .union([
          z.literal("debug"),
          z.literal("info"),
          z.literal("warning"),
          z.literal("error"),
          z.literal("none"),
        ])
        .optional(),
    })
    .optional(),
  metrics: z
    .object({
      /**
       * Hostname to use when reporting to the statsd daemon
       */
      host: z.string().optional(),
      /**
       * Port number of the (typically) statsd daemon.
       */
      port: z.number().optional(),
      /**
       * How often (in ms) to try reconnecting to the daemon
       */
      reconnect_interval: z.number().optional(),
      /**
       * Filter rules guiding logging/sending of metrics. The provided search patterns are applied to existing metrics, and the related 'actions' control whether to 'log' the metric data to disk, 'send' it to the cloud, or neither. The default is to do both, i.e. 'log,send' for all 'ae.epoch.**' metrics.
       */
      rules: z
        .array(
          z.object({
            /**
             * Name pattern for metric (incl wildcards)
             */
            name: z.string().optional(),
            /**
             * type of metric
             */
            type: z.string().optional(),
            /**
             * Specific datapoints: 'default', or names, comma-separated
             */
            datapoints: z.string().optional(),
            /**
             * What to do with matching metrics.
             */
            actions: z.string().optional(),
          })
        )
        .optional(),
    })
    .optional(),
  monitoring: z
    .object({
      /**
       * If true, the monitoring will start.
       */
      active: z.boolean().optional(),
      publisher: z
        .object({
          /**
           * If true, the monitoring will start posting transactions.
           */
          autostart: z.boolean().optional(),
          /**
           * Amount to set up in monitoring spend transaction.
           */
          amount: z.number().optional(),
          /**
           * How often (in ms) to try post monitoring transaction.
           */
          interval: z.number().optional(),
          /**
           * Number of blocks before tx is garbage collected.
           */
          ttl: z.number().optional(),
          /**
           * Public key of transaction publisher.
           */
          pubkey: z.string().optional(),
          /**
           * Private key of transaction publisher serialized as signature.
           */
          privkey: z.string().optional(),
        })
        .optional(),
    })
    .optional(),
  /**
   * Overload sampler configurations. These monitor potential pain points in the system for indications of overload.
   */
  load_levels: z
    .object({
      mempool: z
        .object({
          /**
           * Number of transactions in the mempool
           */
          size: z.string().optional(),
        })
        .optional(),
    })
    .optional(),
  /**
   * Queues regulating the load in a node. Each queue may have a combination of 'rate', 'counter', 'max_size' and 'max_time' parameters. Set a parameter to 0 if you want it to have no effect.
   */
  regulators: z
    .object({
      /**
       * sync node pinger worker pool.
       */
      sync_ping: z
        .object({
          counter: z.number().optional(),
          rate: z.number().optional(),
          max_size: z.number().optional(),
          max_time: z.number().optional(),
        })
        .optional(),
      sync_tasks: z
        .object({
          counter: z.number().optional(),
          rate: z.number().optional(),
          max_size: z.number().optional(),
          max_time: z.number().optional(),
        })
        .optional(),
      sync_gossip: z
        .object({
          counter: z.number().optional(),
          rate: z.number().optional(),
          max_size: z.number().optional(),
          max_time: z.number().optional(),
        })
        .optional(),
      /**
       * mempool updates.
       */
      tx_pool_push: z
        .object({
          counter: z.number().optional(),
          rate: z.number().optional(),
          max_size: z.number().optional(),
          max_time: z.number().optional(),
          rate_modifiers: z.string().optional(),
          counter_modifiers: z.string().optional(),
        })
        .optional(),
      /**
       * State channel websocket handlers.
       */
      sc_ws_handlers: z
        .object({
          counter: z.number().optional(),
          rate: z.number().optional(),
          max_size: z.number().optional(),
          max_time: z.number().optional(),
        })
        .optional(),
      /**
       * HTTP update requests.
       */
      http_update: z
        .object({
          counter: z.number().optional(),
          rate: z.number().optional(),
          max_size: z.number().optional(),
          max_time: z.number().optional(),
        })
        .optional(),
      /**
       * HTTP read requests.
       */
      http_read: z
        .object({
          counter: z.number().optional(),
          rate: z.number().optional(),
          max_size: z.number().optional(),
          max_time: z.number().optional(),
        })
        .optional(),
      /**
       * DB Garbage collection scan chunks
       */
      gc_scan: z
        .object({
          counter: z.number().optional(),
          rate: z.number().optional(),
        })
        .optional(),
    })
    .optional(),
  fork_management: z
    .object({
      /**
       * Identification of the network in case of hard forks.
       */
      network_id: z.string().optional(),
      fork: z
        .record(z.unknown())
        .and(
          z.object({
            /**
             * Indicates whether the node should follow the signalling result or stay with the current protocol.
             */
            enabled: z.boolean(),
            /**
             * Height at which signalling period starts.
             */
            signalling_start_height: z.number().optional(),
            /**
             * Height at which signalling period ends.
             */
            signalling_end_height: z.number().optional(),
            /**
             * Count of the key blocks in signalling period necessary for the fork to take effect.
             */
            signalling_block_count: z.number().optional(),
            /**
             * Pseudorandom number (part of key block) used by the miners indicating which fork they support.
             */
            info_field: z.number().optional(),
            /**
             * Version of the chain in case of a successful fork.
             */
            version: z.number().optional(),
          })
        )
        .optional(),
    })
    .optional(),
  stratum: z
    .object({
      enabled: z.boolean().optional(),
      connection: z
        .object({
          host: z.string().optional(),
          /**
           * Port number of Stratum server.
           */
          port: z.number().optional(),
          max_connections: z.number().optional(),
          num_acceptors: z.number().optional(),
          transport: z.union([z.literal("tcp"), z.literal("ssl")]).optional(),
        })
        .optional(),
      session: z
        .object({
          extra_nonce_bytes: z.number().optional(),
          skip_num_blocks: z.number().optional(),
          initial_share_target: z.number().optional(),
          max_share_target: z.number().optional(),
          desired_solve_time: z.number().optional(),
          max_solve_time: z.number().optional(),
          share_target_diff_threshold: z.number().optional(),
          edge_bits: z.number().optional(),
          max_jobs: z.number().optional(),
          max_workers: z.number().optional(),
          msg_timeout: z.number().optional(),
        })
        .optional(),
      reward: z
        .object({
          reward_last_rounds: z.number().optional(),
          beneficiaries: z.array(z.record(z.unknown())).optional(),
          keys: z
            .object({
              /**
               * Directory of the public/private key pair used for signing of the payout contract call (either relative to aestratum priv directory or absolute). This account holds mining rewards which are scheduled for redistribution to miners. It is unexpected that this account should hold any substantial amount of tokens (in fiat value) - it would mean redistributions aren't working. The pool operator should ensure the node operates in trusted environment.
               */
              dir: z.string().optional(),
            })
            .optional(),
        })
        .optional(),
    })
    .optional(),
  /**
   * Settings for when dev mode consensus is activated
   */
  dev_mode: z
    .object({
      /**
       * Interval, in seconds, between keyblocks. If 0, keyblocks are only produced on-demand
       */
      keyblock_interval: z.number().optional(),
      /**
       * Interval, in seconds, between microblocks. If 0, microblocks are only produced on-demand
       */
      microblock_interval: z.number().optional(),
      /**
       * Emit microblocks as soon as transactions have been pushed to the mempool
       */
      auto_emit_microblocks: z.boolean().optional(),
    })
    .optional(),
});
